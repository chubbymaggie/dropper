class MemoryStore():
    def __init__(self, gts):
        self.gts = gts



    def add(self, gs):
        for g in gs:
            self._verify(g)

    def _verify_mem_store(self, g):
        #we don't want push {something} like gadgets here
        if g.destination[0].name == 'rsp':
            logging.info("Refusing gadget 0x%08x: push like gadget " % g.address)
            return False, 0

        #we don't want mov[rip] like gadgets here
        if g.destination[0].name == 'rip':
            logging.info("Refusing gadget 0x%08x: use a rip relative location " % g.address)
            return False, 0

        for r in [g.destination[0], g.sources[0]]:
            if not self.regset.can_control_reg(r.name):
                logging.info("Refusing gadget 0x%08x: can't control reg %s  " % (g.address, r.name))
                return False, 0


        location = random.randint(0, 2 ** self.arch_info.address_size - 1)
        value = random.randint(0, 2 ** self.arch_info.register_size[g.sources[0].name])

        valid, src, dst = self._mem_set_get_param(g, location, value)

        if valid == False:
            return False, 0

        valid = self._mem_set_is_valid(g, src, dst, location, value)
        if valid == False:
            logging.info("Refusing gadgets 0x%08x: not valid " % g.address)
            return False, 0

        size = self.arch_info.register_size[g.sources[0].name]
        mem_side_effects, stack_at_end = self._mem_set_side_effects(g,
                                                                src,
                                                                dst,
                                                                location,
                                                                size)
        if len(mem_side_effects) > 0:
            logging.info("Refusing gadget 0x%08x: memories side effects " % (g.address))
            return False, 0


        return True, stack_at_end
